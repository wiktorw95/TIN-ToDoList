<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mened≈ºer Zada≈Ñ</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
<div id="List-app">
  <!-- App content will be rendered here -->
</div>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const appContainer = document.getElementById('List-app');
    if (!appContainer) {
      console.error("Nie znaleziono kontenera #List-app");
      return;
    }

    function createElement(tag, classNames = [], textContent = '', attributes = {}) {
      const element = document.createElement(tag);
      if (classNames.length > 0) {
        element.className = classNames.join(' ');
      }
      if (textContent) {
        element.textContent = textContent;
      }

      Object.entries(attributes).forEach(([key, value]) => {
        element.setAttribute(key, value);
      });

      return element;
    }

    function renderTaskForm() {
      const taskForm = createElement('div', ['task-form']);

      const titleInput = createElement('input', [], '', {
        type: 'text',
        id: 'title',
        placeholder: 'Tytu≈Ç zadania'
      });

      // Add error element for title validation
      const titleError = createElement('div', ['error-message'], '', {
        id: 'titleError',
        textContent: '',
        style: ''
      });

      const categorySelect = createElement('select', [], '', {id: 'category'});
      // Optimized: using single key arrays
      ['Kategoria', 'Praca', 'Dom', 'Inne'].forEach((text, idx) => {
        const value = idx === 0 ? '' : text;
        categorySelect.appendChild(createElement('option', [], text, {value}));
      });

      const prioritySelect = createElement('select', [], '', {id: 'priority'});
      // Optimized: using single key arrays with mapping
      ['Priorytet', 'Niski', '≈öredni', 'Wysoki'].forEach((text, idx) => {
        const valueMap = ['', 'low', 'medium', 'high'];
        prioritySelect.appendChild(createElement('option', [], text, {value: valueMap[idx]}));
      });

      const deadlineInput = createElement('input', [], '', {
        type: 'date',
        id: 'deadline'
      });

      const addButton = createElement('button', [], 'Dodaj');
      addButton.addEventListener('click', () => addTask());

      // Append title input and error message together
      const titleContainer = createElement('div');
      titleContainer.appendChild(titleInput);
      titleContainer.appendChild(titleError);

      [titleContainer, categorySelect, prioritySelect, deadlineInput, addButton].forEach(option => taskForm.appendChild(option));

      return taskForm;
    }

    function renderFilterBar() {
      const filterBar = createElement('div', ['filter-bar']);

      const filterInput = createElement('input', [], '', {
        type: 'text',
        id: 'filterText',
        placeholder: 'Filtruj po tytule...'
      });

      const categoryFilter = createElement('select', [], '', {id: 'filterCat'});
      // Optimized: using single key arrays
      ['Wszystkie kategorie', 'Praca', 'Dom', 'Inne'].forEach((text, idx) => {
        const value = idx === 0 ? '' : text;
        categoryFilter.appendChild(createElement('option', [], text, {value}));
      });

      const priorityFilter = createElement('select', [], '', {id: 'filterPri'});
      // Optimized: using single key arrays with mapping
      ['Wszystkie priorytety', 'Niski', '≈öredni', 'Wysoki'].forEach((text, idx) => {
        const valueMap = ['', 'low', 'medium', 'high'];
        priorityFilter.appendChild(createElement('option', [], text, {value: valueMap[idx]}));
      });

      [filterInput, categoryFilter, priorityFilter].forEach(option => filterBar.appendChild(option));

      return filterBar;
    }

    function renderEditModal() {
      const modal = createElement('div', [], '', {
        id: 'editModal'});

      const modalContent = createElement('div', [], '');

      const title = createElement('h3', [], 'Edytuj zadanie');

      const editTitle = createElement('input', [], '', {
        id: 'editTitle',
        placeholder: 'Tytu≈Ç'
      });

      // Add error element for edit title validation
      const editTitleError = createElement('div', ['error-message'], '', {
        id: 'editTitleError',
        textContent: '',
        style: ''
      });

      const editCategory = createElement('select', [], '', {id: 'editCat'});
      // Optimized: using single key arrays
      ['Kategoria', 'Praca', 'Dom', 'Inne'].forEach((text, idx) => {
        const value = idx === 0 ? '' : text;
        editCategory.appendChild(createElement('option', [], text, {value}));
      });

      const editPriority = createElement('select', [], '', {id: 'editPri'});
      // Optimized: using single key arrays with mapping
      ['Priorytet', 'Niski', '≈öredni', 'Wysoki'].forEach((text, idx) => {
        const valueMap = ['', 'low', 'medium', 'high'];
        editPriority.appendChild(createElement('option', [], text, {value: valueMap[idx]}));
      });

      const editDeadline = createElement('input', [], '', {
        type: 'date',
        id: 'editDeadline'
      });

      const saveButton = createElement('button', [], 'Zapisz');
      const cancelButton = createElement('button', [], 'Anuluj');

      // Add event listeners to buttons
      saveButton.addEventListener('click', () => saveEdit());
      cancelButton.addEventListener('click', () => closeEditModal());

      // Create title container with error message
      const titleContainer = createElement('div');
      titleContainer.appendChild(editTitle);
      titleContainer.appendChild(editTitleError);

      [title, titleContainer, editCategory, editPriority, editDeadline, saveButton, cancelButton].forEach(option => modalContent.appendChild(option));

      modal.appendChild(modalContent);

      return modal;
    }

    function renderTaskList() {
      return createElement('ul', [], '', {id: 'taskList'});
    }

    function renderControls() {
      const controls = createElement('div', ['controls']);

      const undoBtn = createElement('button', [], 'Cofnij');
      const redoBtn = createElement('button', [], 'Pon√≥w');
      const exportBtn = createElement('button', [], 'Eksportuj');
      const importInput = createElement('input', [], '', {
        type: 'file',
        id: 'importFile',
        multiple: true
      });

      [undoBtn, redoBtn, exportBtn, importInput].forEach(option => controls.appendChild(option));
      undoBtn.addEventListener('click', () => undo());
      redoBtn.addEventListener('click', () => redo());
      exportBtn.addEventListener('click', () => exportTasks());

      return controls;
    }

    function renderApp() {
      appContainer.innerHTML = '';

      const header = createElement('header');
      const mainTitle = createElement('h1', [], 'Mened≈ºer Zada≈Ñ');
      header.appendChild(mainTitle);

      [header, renderTaskForm(), renderFilterBar(), renderEditModal(), renderTaskList(), renderControls()].forEach(option => appContainer.appendChild(option));
    }

    renderApp();

    let tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
    let history = [], redoStack = [], editIdx = null, stats = { addCount: 0 };

    const elements = {};
    ['title', 'category', 'priority', 'deadline', 'filterText', 'filterCat', 'filterPri', 'importFile', 'taskList', 'editModal', 'editTitle', 'editCat', 'editPri', 'editDeadline', 'titleError', 'editTitleError']
            .forEach(key => elements[key] = document.getElementById(key));

    const save = () => localStorage.setItem('tasks', JSON.stringify(tasks));
    const updateHistory = () => { history.push(JSON.stringify(tasks)); redoStack = []; };
    const sanitize = input => { const div = document.createElement("div"); div.textContent = input; return div.innerHTML; };
    const log = (event, details = "") => console.log(`[LOG] ${new Date().toISOString()} - ${event}: ${details}`);

    const openEditModal = idx => {
      const t = tasks[idx];
      editIdx = idx;
      elements.editTitle.value = t.title;
      elements.editCat.value = t.category || '';
      elements.editPri.value = t.priority || '';
      elements.editDeadline.value = t.deadline || '';
      elements.editModal.style.display = 'flex';
    };

    const closeEditModal = () => {
      const modal = document.getElementById('editModal');
      if (modal) {
        modal.style.display = 'none';
      }

      // Reset edit index
      editIdx = null;

      // Clear error message
      const errorElement = document.getElementById('editTitleError');
      if (errorElement) {
        errorElement.style.display = 'none';
      }
    };

    const saveEdit = () => {
      if (editIdx === null) return;
      const newTitle = elements.editTitle.value.trim();
      const errorElement = document.getElementById('editTitleError');

      if (!newTitle) {
        errorElement.textContent = 'Tytu≈Ç zadania jest wymagany';
        errorElement.style.display = 'block';
        return false;
      }

      updateHistory();
      tasks[editIdx] = {
        ...tasks[editIdx],
        title: sanitize(newTitle),
        category: sanitize(elements.editCat.value),
        priority: sanitize(elements.editPri.value),
        deadline: sanitize(elements.editDeadline.value)
      };

      log("Task Edited", newTitle);
      save();
      render();
      closeEditModal();
    };

    // Task operations
    const addTask = () => {
      const title = sanitize(elements.title.value.trim());
      const errorElement = document.getElementById('titleError');

      if (!title) {
        errorElement.textContent = 'Tytu≈Ç zadania jest wymagany';
        errorElement.style.display = 'block';
        return false;
      }

      errorElement.style.display = 'none';

      updateHistory();
      tasks.push({
        title,
        category: sanitize(elements.category.value),
        priority: sanitize(elements.priority.value),
        deadline: sanitize(elements.deadline.value),
        completed: false
      });

      stats.addCount++;
      log("Task Added", title);
      log("Task Count", stats.addCount);

      elements.title.value = elements.category.value = elements.priority.value = elements.deadline.value = '';
      save();
      render();
    };

    const toggleComplete = idx => {
      updateHistory();
      tasks[idx].completed = !tasks[idx].completed;
      log("Task Completed", tasks[idx].title);
      save();
      render();
    };

    const deleteTask = idx => {
      log("Task Deleted", tasks[idx].title);
      if(stats.addCount !== 0){
        stats.addCount--;
      }
      log("Task Count", stats.addCount);
      updateHistory();
      tasks.splice(idx, 1);
      save();
      render();
    };

    // History operations
    const undo = () => {
      if (history.length > 0) {
        redoStack.push(JSON.stringify(tasks));
        tasks = JSON.parse(history.pop());
        log("Undo", "Undo Element");
        save();
        render();
      }
    };

    const redo = () => {
      if (redoStack.length > 0) {
        history.push(JSON.stringify(tasks));
        tasks = JSON.parse(redoStack.pop());
        log("Redo", "Redo Element");
        save();
        render();
      }
    };

    const exportTasks = () => {
      try {
        const download = (data, name) => {
          const a = document.createElement('a');
          a.href = `data:application/json,${encodeURIComponent(JSON.stringify(data))}`;
          a.download = name;
          a.click();
        };

        download(tasks, 'tasks.json');

        log("Export Completed", "Tasks and settings have been exported");
      } catch (error) {
        console.error('Export error:', error);
        alert('Error during export');
      }
    };

    const importTasks = async e => {
      const files = Array.from(e.target.files);
      if (!files.length) return;

      try {
        const fileData = await Promise.all(files.map(async file => {
          try {
            const text = await file.text();
            return { name: file.name, data: JSON.parse(text) };
          } catch {
            return { name: file.name, data: null };
          }
        }));

        const tasksFile = fileData.find(f => f.name.includes('tasks') && Array.isArray(f.data));
        const settingsFile = fileData.find(f => f.name.includes('settings') && f.data?.stats);

        if (tasksFile) {
          updateHistory();
          tasks = tasksFile.data;
          if (settingsFile) stats = settingsFile.data.stats;
          save();
          render();
          log("Import Complete", `Imported ${tasks.length} tasks`);
        } else {
          alert('Nieprawid≈Çowy format pliku zada≈Ñ');
        }
      } catch (error) {
        console.error('Import error:', error);
        alert('B≈ÇƒÖd odczytu pliku');
      }
    };

    // Render function
    const render = () => {
      elements.taskList.innerHTML = '';
      const fText = elements.filterText.value.toLowerCase();
      const fCat = elements.filterCat.value;
      const fPri = elements.filterPri.value;
      stats.addCount = 0;

      tasks
              .filter(t => t.title.toLowerCase().includes(fText) &&
                      (fCat === '' || t.category === fCat) &&
                      (fPri === '' || t.priority === fPri))
              .forEach((t, idx) => {
                stats.addCount++;
                const li = document.createElement('li');
                li.className = `${t.priority} ${t.completed ? 'completed' : ''}`;
                li.draggable = true;

                // Drag and drop
                li.ondragstart = e => e.dataTransfer.setData('text/plain', idx);
                li.ondragover = e => e.preventDefault();
                li.ondrop = e => {
                  const draggedIdx = e.dataTransfer.getData('text/plain');
                  if (draggedIdx !== idx) {
                    [tasks[draggedIdx], tasks[idx]] = [tasks[idx], tasks[draggedIdx]];
                    log("Moved", "Task  '" + tasks[idx].title + "' changed position with '" + tasks[draggedIdx].title + "'");
                    updateHistory();
                    save();
                    render();
                  }
                };

                // Task content
                const label = document.createElement('label');
                Object.assign(label.style, { display: 'flex', alignItems: 'center', flex: '1' });

                const checkbox = document.createElement('input');
                Object.assign(checkbox, { type: 'checkbox', checked: t.completed, onchange: () => toggleComplete(idx) });

                const textDiv = document.createElement('div');
                const titleEl = document.createElement('strong');
                titleEl.textContent = t.title;

                const metaEl = document.createElement('div');
                metaEl.className = 'meta';
                metaEl.textContent = `${t.category || 'Brak kategorii'} | ${t.priority || 'brak priorytetu'} | ${t.deadline || 'brak terminu'}`;

                textDiv.append(titleEl, metaEl);
                label.append(checkbox, textDiv);

                // Buttons
                const buttonsDiv = document.createElement('div');
                const editBtn = document.createElement('button');
                const deleteBtn = document.createElement('button');

                Object.assign(editBtn, { textContent: '‚úèÔ∏è', onclick: () => openEditModal(idx) });
                Object.assign(deleteBtn, { textContent: 'üóëÔ∏è', onclick: () => deleteTask(idx) });

                buttonsDiv.append(editBtn, deleteBtn);
                li.append(label, buttonsDiv);
                elements.taskList.appendChild(li);
              });
    };

    // Event listeners
    elements.importFile.addEventListener('change', importTasks);
    elements.filterText.addEventListener('input', render);
    elements.filterCat.addEventListener('change', render);
    elements.filterPri.addEventListener('change', render);

    // Batch operations with Promise.all
    const batchOperation = async (selected, operation) => {
      updateHistory();

      if (operation === 'complete') {
        selected.forEach(idx => {
          tasks[idx].completed = true;
          log("Task Completed", tasks[idx].title);
        });
      } else if (operation === 'delete') {
        selected.forEach(idx => log("Task Deleted", tasks[idx].title));
        selected.reverse().forEach(idx => tasks.splice(idx, 1));
      }

      save();
      render();
    };

// Add bulk operations to the interface
    const addBulkControls = () => {
      const controls = document.querySelector('.controls');
      const bulkDiv = document.createElement('div');

      const buttons = [
        { text: 'Zaznacz widoczne', onclick: selectAllVisible },
        { text: 'Uko≈Ñcz zaznaczone', onclick: () => executeSelected('complete') },
        { text: 'Usu≈Ñ zaznaczone', onclick: () => executeSelected('delete') }
      ];

      buttons.forEach(btn => {
        const button = document.createElement('button');
        button.textContent = btn.text;
        button.onclick = btn.onclick;
        bulkDiv.appendChild(button);
      });

      controls.appendChild(bulkDiv);
    };

    let selectedTasks = new Set();

    const selectAllVisible = () => {
      const visibleTasks = document.querySelectorAll('#taskList li');
      selectedTasks.clear();
      visibleTasks.forEach((li, idx) => {
        selectedTasks.add(idx);
        li.style.backgroundColor = '#e3f2fd';
      });
    };

    const executeSelected = async (operation) => {
      if (selectedTasks.size > 0) {
        await batchOperation([...selectedTasks], operation);
        selectedTasks.clear();
      }
    };

    const initialize = () => {
      try {
        render();
        addBulkControls();
        log("App Initialized", "Task Manager ready");
      } catch (error) {
        console.error('Initialization error:', error);
      }
    };

    initialize();
  });
</script>
</body>
</html>