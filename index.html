<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Menedżer Zadań</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
<div id="List-app">
  <!-- App content will be rendered here -->
</div>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    const appContainer = document.getElementById('List-app');
    if (!appContainer) {
      console.error("Nie znaleziono kontenera #List-app");
      return;
    }

    function createElement(tag, classNames = [], textContent = '', attributes = {}) {
      const element = document.createElement(tag);
      if (classNames.length > 0) {
        element.className = classNames.join(' ');
      }
      if (textContent) {
        element.textContent = textContent;
      }

      Object.entries(attributes).forEach(([key, value]) => {
        element.setAttribute(key, value);
      });

      return element;
    }

    function renderTaskForm() {
      const taskForm = createElement('div', ['task-form']);

      const titleInput = createElement('input', [], '', {
        type: 'text',
        id: 'title',
        placeholder: 'Tytuł zadania'
      });

      // Add error element for title validation
      const titleError = createElement('div', ['error-message'], '', {
        id: 'title-error',
        textContent: '',
        style: ''
      });

      const categorySelect = createElement('select', [], '', {id: 'category'});
      [['Kategoria', ''], ['Praca'], ['Dom'], ['Inne']].forEach(([text, value = text]) =>
              categorySelect.appendChild(createElement('option', [], text, {value}))
      );

      const prioritySelect = createElement('select', [], '', {id: 'priority'});
      [['Priorytet', ''], ['Niski', 'low'], ['Średni', 'medium'], ['Wysoki', 'high']].forEach(([text, value]) =>
              prioritySelect.appendChild(createElement('option', [], text, {value}))
      );

      const deadlineInput = createElement('input', [], '', {
        type: 'date',
        id: 'deadline'
      });

      const addButton = createElement('button', [], 'Dodaj');
      addButton.addEventListener('click', () => addTask());

      // Append title input and error message together
      const titleContainer = createElement('div');
      titleContainer.appendChild(titleInput);
      titleContainer.appendChild(titleError);

      [titleContainer, categorySelect, prioritySelect, deadlineInput, addButton].forEach(option => taskForm.appendChild(option));

      return taskForm;
    }

    function renderFilterBar() {
      const filterBar = createElement('div', ['filter-bar']);

      const filterInput = createElement('input', [], '', {
        type: 'text',
        id: 'filter-input', // ✓ Matches els.filterText
        placeholder: 'Filtruj po tytule...'
      });

      const categoryFilter = createElement('select', [], '', {id: 'filter-category'}); // ✓ Matches els.filterCat
      [['Wszystkie kategorie', ''], ['Praca'], ['Dom'], ['Inne']].forEach(([text, value = text]) =>
              categoryFilter.appendChild(createElement('option', [], text, {value}))
      );

      const priorityFilter = createElement('select', [], '', {id: 'filter-priority'}); // ✓ Matches els.filterPri
      [['Wszystkie priorytety', ''], ['Niski', 'low'], ['Średni', 'medium'], ['Wysoki', 'high']].forEach(([text, value]) =>
              priorityFilter.appendChild(createElement('option', [], text, {value}))
      );

      [filterInput, categoryFilter, priorityFilter].forEach(option => filterBar.appendChild(option));

      return filterBar;
    }

    function renderEditModal() {
      const modal = createElement('div', [], '', {
        id: 'edit-modal',
        style: 'display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.4); justify-content:center; align-items:center; z-index:1000;'
      });

      const modalContent = createElement('div', [], '', {
        style: 'background:#fff; padding:20px; border-radius:10px; width:90%; max-width:400px;'
      });

      const title = createElement('h3', [], 'Edytuj zadanie');

      const editTitle = createElement('input', [], '', {
        id: 'edit-title',
        placeholder: 'Tytuł'
      });

      // Add error element for edit title validation
      const editTitleError = createElement('div', ['error-message'], '', {
        id: 'edit-title-error',
        textContent: '',
        style: ''
      });

      const editCategory = createElement('select', [], '', {id: 'edit-category'});
      [['Kategoria', ''], ['Praca'], ['Dom'], ['Inne']].forEach(([text, value = text]) =>
              editCategory.appendChild(createElement('option', [], text, {value}))
      );

      const editPriority = createElement('select', [], '', {id: 'edit-priority'});
      [['Priorytet', ''], ['Niski', 'low'], ['Średni', 'medium'], ['Wysoki', 'high']].forEach(([text, value]) =>
              editPriority.appendChild(createElement('option', [], text, {value}))
      );

      const editDeadline = createElement('input', [], '', {
        type: 'date',
        id: 'edit-deadline'
      });

      const saveButton = createElement('button', [], 'Zapisz');
      const cancelButton = createElement('button', [], 'Anuluj');

      // Add event listeners to buttons
      saveButton.addEventListener('click', () => saveEdit());
      cancelButton.addEventListener('click', () => closeEditModal());

      // Create title container with error message
      const titleContainer = createElement('div');
      titleContainer.appendChild(editTitle);
      titleContainer.appendChild(editTitleError);

      [title, titleContainer, editCategory, editPriority, editDeadline, saveButton, cancelButton].forEach(option => modalContent.appendChild(option));

      modal.appendChild(modalContent);

      return modal;
    }

    function renderTaskList() {
      return createElement('ul', [], '', {id: 'task-list'});
    }

    function renderControls() {
      const controls = createElement('div', ['controls']);

      const undoBtn = createElement('button', [], 'Cofnij');
      const redoBtn = createElement('button', [], 'Ponów');
      const exportBtn = createElement('button', [], 'Eksportuj');
      const importInput = createElement('input', [], '', {
        type: 'file',
        id: 'import-file', // ✓ Matches els.importFile
        multiple: true
      });

      [undoBtn, redoBtn, exportBtn, importInput].forEach(option => controls.appendChild(option));
      undoBtn.addEventListener('click', () => undo());
      redoBtn.addEventListener('click', () => redo());
      exportBtn.addEventListener('click', () => exportTasks());

      return controls;
    }

    function renderApp() {
      appContainer.innerHTML = '';

      const header = createElement('header');
      const mainTitle = createElement('h1', [], 'Menedżer Zadań');
      header.appendChild(mainTitle);

      [header, renderTaskForm(), renderFilterBar(), renderEditModal(), renderTaskList(), renderControls()].forEach(option => appContainer.appendChild(option));
    }

// Call renderApp first to create the DOM elements
    renderApp();

// IMPORTANT: Move the els object AFTER renderApp() is called
    let tasks = JSON.parse(localStorage.getItem('tasks') || '[]');
    let history = [], redoStack = [], editIdx = null, stats = { addCount: 0 };

// DOM elements - NOW they will exist when this runs
    const els = {};
    [
      { key: 'title', id: 'title' },
      { key: 'category', id: 'category' },
      { key: 'priority', id: 'priority' },
      { key: 'deadline', id: 'deadline' },
      { key: 'filterText', id: 'filter-input' },
      { key: 'filterCat', id: 'filter-category' },
      { key: 'filterPri', id: 'filter-priority' },
      { key: 'importFile', id: 'import-file' },
      { key: 'taskList', id: 'task-list' },
      { key: 'editModal', id: 'edit-modal' },
      { key: 'editTitle', id: 'edit-title' },
      { key: 'editCat', id: 'edit-category' },
      { key: 'editPri', id: 'edit-priority' },
      { key: 'editDeadline', id: 'edit-deadline' },
      { key: 'titleError', id: 'title-error' },
      { key: 'editTitleError', id: 'edit-title-error' }
    ].forEach(({ key, id }) => els[key] = document.getElementById(id));

  // Utility functions
  const save = () => localStorage.setItem('tasks', JSON.stringify(tasks));
  const updateHistory = () => { history.push(JSON.stringify(tasks)); redoStack = []; };
  const sanitize = input => { const div = document.createElement("div"); div.textContent = input; return div.innerHTML; };
  const log = (event, details = "") => console.log(`[LOG] ${new Date().toISOString()} - ${event}: ${details}`);

  // Modal functions
  const openEditModal = idx => {
    const t = tasks[idx];
    editIdx = idx;
    els.editTitle.value = t.title;
    els.editCat.value = t.category || '';
    els.editPri.value = t.priority || '';
    els.editDeadline.value = t.deadline || '';
    els.editModal.style.display = 'flex';
  };

    const closeEditModal = () => {
      const modal = document.getElementById('edit-modal');
      if (modal) {
        modal.style.display = 'none';
      }

      // Reset edit index
      editIdx = null;

      // Clear error message
      const errorElement = document.getElementById('edit-title-error');
      if (errorElement) {
        errorElement.style.display = 'none';
      }
    };

  const saveEdit = () => {
    if (editIdx === null) return;
    const newTitle = els.editTitle.value.trim();
    const errorElement = document.getElementById('edit-title-error');

    if (!newTitle) {
      errorElement.textContent = 'Tytuł zadania jest wymagany';
      errorElement.style.display = 'block';
      return false;
    }

    updateHistory();
    tasks[editIdx] = {
      ...tasks[editIdx],
      title: sanitize(newTitle),
      category: sanitize(els.editCat.value),
      priority: sanitize(els.editPri.value),
      deadline: sanitize(els.editDeadline.value)
    };

    log("Task Edited", newTitle);
    save();
    render();
    closeEditModal();
  };

  // Task operations
  const addTask = () => {
    const title = sanitize(els.title.value.trim());
    const errorElement = document.getElementById('title-error');

    if (!title) {
      errorElement.textContent = 'Tytuł zadania jest wymagany';
      errorElement.style.display = 'block';
      return false;
    }

    errorElement.style.display = 'none';

    updateHistory();
    tasks.push({
      title,
      category: sanitize(els.category.value),
      priority: sanitize(els.priority.value),
      deadline: sanitize(els.deadline.value),
      completed: false
    });

    stats.addCount++;
    log("Task Added", title);
    log("Task Count", stats.addCount);

    els.title.value = els.category.value = els.priority.value = els.deadline.value = '';
    save();
    render();
  };

  const toggleComplete = idx => {
    updateHistory();
    tasks[idx].completed = !tasks[idx].completed;
    log("Task Completed", tasks[idx].title);
    save();
    render();
  };

  const deleteTask = idx => {
    log("Task Deleted", tasks[idx].title);
    if(stats.addCount !== 0){
      stats.addCount--;
    }
    log("Task Count", stats.addCount);
    updateHistory();
    tasks.splice(idx, 1);
    save();
    render();
  };

  // History operations
  const undo = () => {
    if (history.length > 0) {
      redoStack.push(JSON.stringify(tasks));
      tasks = JSON.parse(history.pop());
      log("Undo", "Undo Element");
      save();
      render();
    }
  };

  const redo = () => {
    if (redoStack.length > 0) {
      history.push(JSON.stringify(tasks));
      tasks = JSON.parse(redoStack.pop());
      log("Redo", "Redo Element");
      save();
      render();
    }
  };

  // Import/Export with Promise.all

    const exportTasks = () => {
      try {
        const download = (data, name) => {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(new Blob([JSON.stringify(data)], { type: 'application/json' }));
          a.download = name;
          a.click();
          URL.revokeObjectURL(a.href);
        };

        download(tasks, 'tasks.json');
        download({ stats, exportDate: new Date().toISOString() }, 'settings.json');

        log("Export Completed", "Tasks and settings have been exported");
      } catch (error) {
        console.error('Export error:', error);
        alert('Error during export');
      }
    };

    const importTasks = async e => {
      const files = Array.from(e.target.files);
      if (!files.length) return;

      try {
        const fileData = await Promise.all(files.map(file =>
                new Promise(resolve => {
                  const reader = new FileReader();
                  reader.onload = () => {
                    try {
                      resolve({ name: file.name, data: JSON.parse(reader.result) });
                    } catch {
                      resolve({ name: file.name, data: null });
                    }
                  };
                  reader.readAsText(file);
                })
        ));

        const tasksFile = fileData.find(f => f.name.includes('tasks') && Array.isArray(f.data));
        const settingsFile = fileData.find(f => f.name.includes('settings') && f.data?.stats);

        if (tasksFile) {
          updateHistory();
          tasks = tasksFile.data;
          if (settingsFile) stats = settingsFile.data.stats;
          save();
          render();
          log("Import Complete", `Imported ${tasks.length} tasks`);
        } else {
          alert('Nieprawidłowy format pliku zadań');
        }
      } catch (error) {
        console.error('Import error:', error);
        alert('Błąd odczytu pliku');
      }
    };

  // Render function
  const render = () => {
    els.taskList.innerHTML = '';
    const fText = els.filterText.value.toLowerCase();
    const fCat = els.filterCat.value;
    const fPri = els.filterPri.value;
    stats.addCount = 0;

    tasks
            .filter(t => t.title.toLowerCase().includes(fText) &&
                    (fCat === '' || t.category === fCat) &&
                    (fPri === '' || t.priority === fPri))
            .forEach((t, idx) => {
              stats.addCount++;
              const li = document.createElement('li');
              li.className = `${t.priority} ${t.completed ? 'completed' : ''}`;
              li.draggable = true;

              // Drag and drop
              li.ondragstart = e => e.dataTransfer.setData('text/plain', idx);
              li.ondragover = e => e.preventDefault();
              li.ondrop = e => {
                const draggedIdx = e.dataTransfer.getData('text/plain');
                if (draggedIdx != idx) {
                  [tasks[draggedIdx], tasks[idx]] = [tasks[idx], tasks[draggedIdx]];
                  log("Moved", "Task  '" + tasks[idx].title + "' changed position with '" + tasks[draggedIdx].title + "'");
                  updateHistory();
                  save();
                  render();
                }
              };

              // Task content
              const label = document.createElement('label');
              Object.assign(label.style, { display: 'flex', alignItems: 'center', flex: '1' });

              const checkbox = document.createElement('input');
              Object.assign(checkbox, { type: 'checkbox', checked: t.completed, onchange: () => toggleComplete(idx) });

              const textDiv = document.createElement('div');
              const titleEl = document.createElement('strong');
              titleEl.textContent = t.title;

              const metaEl = document.createElement('div');
              metaEl.className = 'meta';
              metaEl.textContent = `${t.category || 'Brak kategorii'} | ${t.priority || 'brak priorytetu'} | ${t.deadline || 'brak terminu'}`;

              textDiv.append(titleEl, metaEl);
              label.append(checkbox, textDiv);

              // Buttons
              const buttonsDiv = document.createElement('div');
              const editBtn = document.createElement('button');
              const deleteBtn = document.createElement('button');

              Object.assign(editBtn, { textContent: '✏️', onclick: () => openEditModal(idx) });
              Object.assign(deleteBtn, { textContent: '🗑️', onclick: () => deleteTask(idx) });

              buttonsDiv.append(editBtn, deleteBtn);
              li.append(label, buttonsDiv);
              els.taskList.appendChild(li);
            });
  };

  // Event listeners
  els.importFile.addEventListener('change', importTasks);
  els.filterText.addEventListener('input', render);
  els.filterCat.addEventListener('change', render);
  els.filterPri.addEventListener('change', render);

  // Batch operations with Promise.all
  const batchComplete = async (taskIndices) => {
    updateHistory();

    // Complete multiple tasks simultaneously
    await Promise.all(
            taskIndices.map(async (idx) => {
              tasks[idx].completed = true;
              log("Task Completed", tasks[idx].title);
              return Promise.resolve();
            })
    );

    save();
    render();
  };

  const batchDelete = async (taskIndices) => {
    updateHistory();

    // Log all deletions simultaneously
    await Promise.all(
            taskIndices.map(async (idx) => {
              log("Task Deleted", tasks[idx].title);
              return Promise.resolve();
            })
    );

    // Remove tasks (reverse order to maintain indices)
    taskIndices.reverse().forEach(idx => tasks.splice(idx, 1));

    save();
    render();
  };

  // Add bulk operations to the interface
    const addBulkControls = () => {
      const controls = document.querySelector('.controls');
      const bulkDiv = document.createElement('div');

      const selectBtn = document.createElement('button');
      selectBtn.textContent = 'Zaznacz widoczne';
      selectBtn.onclick = selectAllVisible;

      const completeBtn = document.createElement('button');
      completeBtn.textContent = 'Ukończ zaznaczone';
      completeBtn.onclick = completeSelected;

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Usuń zaznaczone';
      deleteBtn.onclick = deleteSelected;

      bulkDiv.appendChild(selectBtn);
      bulkDiv.appendChild(completeBtn);
      bulkDiv.appendChild(deleteBtn);
      controls.appendChild(bulkDiv);
    };

    let selectedTasks = new Set();

    const selectAllVisible = () => {
      const visibleTasks = document.querySelectorAll('#task-list li');
      selectedTasks.clear();
      visibleTasks.forEach((li, idx) => {
        selectedTasks.add(idx);
        li.style.backgroundColor = '#e3f2fd';
      });
    };

    const completeSelected = async () => {
      if (selectedTasks.size > 0) {
        await batchComplete([...selectedTasks]);
        selectedTasks.clear();
      }
    };

    const deleteSelected = async () => {
      if (selectedTasks.size > 0) {
        await batchDelete([...selectedTasks]);
        selectedTasks.clear();
      }
    };

    const initialize = () => {
      try {
        render();
        addBulkControls();
        log("App Initialized", "Task Manager ready");
      } catch (error) {
        console.error('Initialization error:', error);
      }
    };

  initialize();
  });
</script>
</body>
</html>